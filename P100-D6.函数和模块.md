#### 1.函数
在Python中，函数的参数可以有默认值（可以不传入参数，或不按顺序传入），也支持使用可变参数，所以Python并不需要像其他语言一样支持函数的重载。  
在参数名前面的 * 表示args是一个可变参数，即参数个数由调用者来决定  
若在调用函数时没有传入对应参数的值，则将使用该参数的默认值，所以可以用各种不同的方式去调用函数，这跟其他很多语言中函数重载的效果是一致的。  

#### 2.模块
由于Python没有函数重载，前面的同名函数会被后者覆盖。  
怎么解决这种命名冲突呢？答案其实很简单，Python中每个.py文件就代表了一个模块（module），不同的模块中可以有同名的函数。  
在使用函数的时候通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数：  
1）每导入一次就调用一次foo, 即foo()紧跟import之后  
2）file开头集中导入import module1 as m1，调用时m1.foo()

注意：  
1）module所在的文件夹要添加到系统路径中，详细可见[模块搜索路径](runoob.com/python/python-modules.html)  
```
# module1.py文件要在路径中，注意路径中用反斜杠
module1path = 'F:/PycharmProjects/Python-100-Days/D6_function_module'
sys.path.append(module1path)
```

2）如果在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是`<"__main__">`。  
```
# __name__是Python中一个隐含的变量它代表了模块的名字
# 只有被Python解释器直接执行的模块的名字才是__main__
if __name__ == '__main__':
    print('call foo()')
    foo()
    print('call bar()')
    bar()
```

#### 3.变量的作用域
```
def foo():
    b = 'hello'

    # Python中可以在函数内部再定义函数
    def bar():
        c = True
        print(a)
        print(b)
        print(c)

    bar()
    # print(c)  # NameError: name 'c' is not defined


if __name__ == '__main__':
    a = 100
    # print(b)  # NameError: name 'b' is not defined
    foo()
```
Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，所谓的“内置作用域”就是Python内置的那些标识符，我们之前用过的input、print、int等都属于内置作用域。  
a是一个全局变量（global variable），属于全局作用域，因为它没有定义在任何一个函数中。  
在上面的foo函数中我们定义了变量b，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在foo函数的外部并不能访问到它；  
但对于foo函数内部的bar函数来说，变量b属于嵌套作用域，在bar函数中我们是可以访问到它的。  
bar函数中的变量c属于局部作用域，在bar函数之外是无法访问的。

在foo函数内部定义a = 200 无法改变全局变量a的值，我们可以使用global关键字来指示foo函数中的变量a来自于全局作用域，如果全局作用域中没有a，那么foo函数内的下面一行代码就会定义变量a并将其置于全局作用域。  
同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用nonlocal关键字来指示变量来自于嵌套作用域。

在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用。因此，从现在开始我们可以将Python代码按照下面的格式进行书写，这一点点的改进其实就是在我们理解了函数和作用域的基础上跨出的巨大的一步。  
```
def main():
    # Todo: Add your code here
    pass


if __name__ == '__main__':
    main()
```

#### 4.Python的内置函数
- 数学相关: abs（绝对值或模） / divmod(商和余数） / pow（幂） / round（取整，尽量避免使用） / min / max / sum
- 序列相关: len / range / next(返回迭代器的下一个项目,和生成迭代器的iter() 函数一起使用) / filter(过滤掉不符合条件的元素) / map / sorted / slice / reversed
- 类型转换: chr / ord / str / bool / int / float / complex / bin / oct / hex
- 数据结构: dict / list / set / tuple
- 其他函数: all / any / id / input / open / print / type

[菜鸟教程 Python3内置函数](https://www.runoob.com/python3/python3-built-in-functions.html)

菜鸟教程：abs(119L)=119，长整型(long integers) - 无限大小的整数，整数最后是一个大写或小写的L  
但119L或119l都会报错，原因就是Python3.0之后採用不同的语法，在长整数方面已经取消在整数后面加入L的语法，由于所有数字会自己主动识别为短整数，还是长整数，不须要添加L了。

[round参考](https://www.runoob.com/w3cnote/python-round-func-note.html) 

菜鸟教程max:  
假设列表里面是元组构成元素, 按照元素里面元组的第一个元素的排列顺序，输出最大值（如果第一个元素相同，则比较第二个元素，输出最大值）据推理是按ascii码进行排序的，因为ascii 码里面，按照排列顺序a在 A的后面。
```
l1 = [('a', 1), ('A', 2)]
max(l1)  # ('a', 1)，说明不是只有数字可排序
l2 = [(1, 5), (2, 3)]
max(l2)  # (2, 3)，说明不是求和后排序

a=[(1,3),(2,2),(3,1),(3,'b'),('a',1),('f',3)]
max(a)  # TypeError: '>' not supported between instances of 'str' and 'int'
a=[('1',3),('2',2),('3',1),('3','b'),('a',1),('f',3)]
max(a)  # TypeError: '>' not supported between instances of 'str' and 'int'
# Python3 与Python2 有较大的不同

a = {1: 2, 2: 2, 3: 1, 4: 'aa'}   
max(a)  # 4，比较字典里面的最大值，会输出最大的键值

sum([0,1,2,3,4], 2)      # 列表计算总和后再加 2，逗号后缺省为0
```

