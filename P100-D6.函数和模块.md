#### 1.函数
在Python中，函数的参数可以有默认值（可以不传入参数，或不按顺序传入），也支持使用可变参数，所以Python并不需要像其他语言一样支持函数的重载。  
在参数名前面的 * 表示args是一个可变参数，即参数个数由调用者来决定  
若在调用函数时没有传入对应参数的值，则将使用该参数的默认值，所以可以用各种不同的方式去调用函数，这跟其他很多语言中函数重载的效果是一致的。  

#### 2.模块
由于Python没有函数重载，前面的同名函数会被后者覆盖。  
怎么解决这种命名冲突呢？答案其实很简单，Python中每个.py文件就代表了一个模块（module），不同的模块中可以有同名的函数。  
在使用函数的时候通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数：  
1）每导入一次就调用一次foo, 即foo()紧跟import之后  
2）file开头集中导入import module1 as m1，调用时m1.foo()

注意：  
1）module所在的文件夹要添加到系统路径中，详细可见[模块搜索路径](runoob.com/python/python-modules.html)  
```
# module1.py文件要在路径中，注意路径中用反斜杠
module1path = 'F:/PycharmProjects/Python-100-Days/D6_function_module'
sys.path.append(module1path)
```

2）如果在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是`<"__main__">`。  
```
# __name__是Python中一个隐含的变量它代表了模块的名字
# 只有被Python解释器直接执行的模块的名字才是__main__
if __name__ == '__main__':
    print('call foo()')
    foo()
    print('call bar()')
    bar()
```

#### 3.变量的作用域
```
def foo():
    b = 'hello'

    # Python中可以在函数内部再定义函数
    def bar():
        c = True
        print(a)
        print(b)
        print(c)

    bar()
    # print(c)  # NameError: name 'c' is not defined


if __name__ == '__main__':
    a = 100
    # print(b)  # NameError: name 'b' is not defined
    foo()
```
Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，所谓的“内置作用域”就是Python内置的那些标识符，我们之前用过的input、print、int等都属于内置作用域。  
a是一个全局变量（global variable），属于全局作用域，因为它没有定义在任何一个函数中。  
在上面的foo函数中我们定义了变量b，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在foo函数的外部并不能访问到它；  
但对于foo函数内部的bar函数来说，变量b属于嵌套作用域，在bar函数中我们是可以访问到它的。  
bar函数中的变量c属于局部作用域，在bar函数之外是无法访问的。

在foo函数内部定义a = 200 无法改变全局变量a的值，我们可以使用global关键字来指示foo函数中的变量a来自于全局作用域，如果全局作用域中没有a，那么foo函数内的下面一行代码就会定义变量a并将其置于全局作用域。  
同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用nonlocal关键字来指示变量来自于嵌套作用域。

在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用。因此，从现在开始我们可以将Python代码按照下面的格式进行书写，这一点点的改进其实就是在我们理解了函数和作用域的基础上跨出的巨大的一步。  
```
def main():
    # Todo: Add your code here
    pass


if __name__ == '__main__':
    main()
```
